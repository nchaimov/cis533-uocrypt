Nicholas Chaimov
CIS 533 Computer & Network Security
Winter 2013
Assignment #1: Secure Copy Utility

Files submitted:
	README        (this file)
	uocrypt.c, .h (cryptography routines)
	uoio.c, .h    (file and network I/O routines)
	test.c        (sanity checks of libgcrypt usage)
	uoenc.c       (encryption & file-sending utility)
	uodec.c       (decryption & file-receiving utility)
	
Work accomplished:
	Everything required in the assignment details is implemented,
	as far as I am aware. Specifically,
		- the programs are written in C
		- use libgcrypt
		- take the command line arguments indicated
		- follow the file naming conventions indicated
		- prompt the user for a password on each invocation
		- generate the key from the password by PBKDF2
		- attach an HMAC (in uoenc) and verify the HMAC (in uodec)
		- encrypt and decrypt using AES256
		- and display an error and abort if the output file already exists
		
Description of code and code layout:
	Routines which call libgcrypt are in uocrypt.c, so that uoenc and uodec
	are largely independent of the particular encryption implementation.
	Routines which deal with file and network I/O are in uoio.c
	uoenc and uodec call routines in uocrypt and uoio.
	
Design decisions:
	In key derivation, 64,000 iterations are used, which is recommended by
	OWASP (https://www.owasp.org/index.php/Password_Storage_Cheat_Sheet: 
	'A minimum of 1000 operations was recommended in the RSA PKCS5 standard
	in 2000, a value that should be doubled every 2 years. Therefore, in 
	2012, it is recommended that 64,000 iterations be considered.')
	SHA-512 is used as the underlying hash fin PBKDF2.
	
	AES256 is used in Cipher Feedback mode, which does not require that the
	length of the encrypted message be a multiple of the block size, so
	padding is not needed. The initialization vector is randomly generated
	by libgcrypt's random number functions and is sent/stored along with
	the encrypted data.
	
	The underlying hash used for HMAC is SHA-512.
	
A question:
	There will be a particular decision youâ€™ll need to make for dealing with
	PBKDF2. What extra input does it require and why is this used? How does
	your program deal with it?
	
	I suspect this is asking about the salt, an extra input to the key
	derivation function which is used to prevent an attacker from precomputing
	hashes for passwords; the attacker instead needs to precompute hashes for
	all possible password/salt pairs, a vastly larger search space.
	The salt is randomly generated by libgcrypt's random number generation
	functions (as with the IV for AES256) and is sent/stored along with the
	encrypted data.
	
Hours/effort:
	I estimate that I spent 10 +/- 2 hours (spread over two weeks) on the 
	assignment and that it required moderate effort.